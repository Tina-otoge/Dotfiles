import os
import ycm_core

flags = [
'-Wall',
'-Wextra',
'-Werror',
'-Wno-long-long',
'-Wno-variadic-macros',
'-fexceptions',
'-DNDEBUG',
'-I.',
'-I./ClangCompleter',
'-I./include',
'-I../include',
# only for ycm / completers
'-DUSE_CLANG_COMPLETER'
]


SOURCE_EXTENSIONS = [ '.cpp', '.cxx', '.cc', '.c', '.m', '.mm' ]

def DirectoryOfThisScript():
  return '.'


def IsHeaderFile( filename ):
  extension = os.path.splitext( filename )[ 1 ]
  return extension in [ '.h', '.hxx', '.hpp', '.hh' ]


def GetCompilationInfoForFile( filename ):
  # The compilation_commands.json file generated by CMake does not have entries
  # for header files. So we do our best by asking the db for flags for a
  # corresponding source file, if any. If one exists, the flags for that file
  # should be good enough.
  if IsHeaderFile( filename ):
    basename = os.path.splitext( filename )[ 0 ]
    for extension in SOURCE_EXTENSIONS:
      replacement_file = basename + extension
      if os.path.exists( replacement_file ):
        compilation_info = database.GetCompilationInfoForFile(
          replacement_file )
        if compilation_info.compiler_flags_:
          return compilation_info
    return None
  return database.GetCompilationInfoForFile( filename )


def FlagsForFile( filename, **kwargs ):
  if os.path.splitext( filename )[ 1 ] is '.c':
    flags.append('-std=c99')
    flags.append('-c')
  if os.path.splitext( filename )[ 1 ] in ['.cpp', '.cxx', '.cc', '.C']:
    flags.append('-std=c++11')
    flags.append('-cc')
  return {
    'flags': flags,
    'include_paths_relative_to_dir': DirectoryOfThisScript()
  }
